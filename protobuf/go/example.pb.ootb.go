// Code generated by protoc-gen-ootb. DO NOT EDIT!
// source: example.proto

package example

import (
	"context"
	"net/http"

	"github.com/appootb/substratum/v2/gateway"
	"github.com/appootb/substratum/v2/proto/go/permission"
	"github.com/appootb/substratum/v2/service"
	"github.com/grpc-ecosystem/grpc-gateway/v2/runtime"
	"golang.org/x/net/websocket"
	"google.golang.org/grpc"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// ensure the imports are used
var (
	_ = http.StatusOK
	_ = runtime.String
	_ = context.TODO()
	_ = gateway.WebStream{}
	_ = grpc.ServiceDesc{}
	_ = websocket.UnknownFrame
	_ = permission.Subject_NONE
	_ = service.UnaryServerInterceptor
)

var _myServiceServiceSubjects = map[string][]permission.Subject{
	"/example.MyService/Login": {
		permission.Subject_NONE,
	},
	"/example.MyService/Stream": {
		permission.Subject_MOBILE, permission.Subject_PC, permission.Subject_WEB,
	},
}

var _myServiceServiceRoles = map[string][]string{}

type wrapperMyServiceServer struct {
	MyServiceServer
	service.Implementor
}

func (w *wrapperMyServiceServer) Login(ctx context.Context, req *emptypb.Empty) (*Token, error) {
	if w.UnaryInterceptor() == nil {
		return w.MyServiceServer.Login(ctx, req)
	}
	info := &grpc.UnaryServerInfo{
		Server:     w.MyServiceServer,
		FullMethod: "/example.MyService/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return w.MyServiceServer.Login(ctx, req.(*emptypb.Empty))
	}
	resp, err := w.UnaryInterceptor()(ctx, req, info, handler)
	if err != nil {
		return nil, err
	}
	return resp.(*Token), nil
}

func (w *wrapperMyServiceServer) Stream(srv MyService_StreamServer) error {
	return w.MyServiceServer.Stream(srv)
}

// Register scoped server.
func RegisterMyServiceScopeServer(component string, auth service.Authenticator, impl service.Implementor, srv MyServiceServer) error {
	// Register service required subjects.
	auth.RegisterServiceSubjects(component, _myServiceServiceSubjects, _myServiceServiceRoles)

	// Register scoped gRPC server.
	for _, gRPC := range impl.GetGRPCServer(permission.VisibleScope_CLIENT) {
		RegisterMyServiceServer(gRPC, srv)
	}
	// Register scoped gateway handler server.
	wrapper := wrapperMyServiceServer{
		MyServiceServer: srv,
		Implementor:     impl,
	}

	for _, mux := range impl.GetGatewayMux(permission.VisibleScope_CLIENT) {
		// Register gateway handler.
		if err := RegisterMyServiceHandlerServer(impl.Context(), mux, &wrapper); err != nil {
			return err
		}
		// Register websocket handler.
		if err := RegisterMyServiceWsHandlerServer(mux, srv, impl.StreamInterceptor()); err != nil {
			return err
		}
	}
	return nil
}

func RegisterMyServiceWsHandlerServer(mux *runtime.ServeMux, srv MyServiceServer, streamInterceptor grpc.StreamServerInterceptor) error {

	mux.Handle("GET", ws_pattern_MyService_Stream_0, func(w http.ResponseWriter, r *http.Request, pathParams map[string]string) {
		fn := func(c *websocket.Conn) {
			ctx, err := runtime.AnnotateIncomingContext(r.Context(), mux, r, "/example.MyService/Stream")
			if err != nil {
				_ = c.WriteClose(http.StatusBadRequest)
				return
			}
			inbound, outbound := runtime.MarshalerForRequest(mux, r)
			stream := gateway.NewWebsocketStream(ctx, c, inbound, outbound)
			if streamInterceptor == nil {
				err = srv.Stream(&myServiceStreamServer{stream})
				if err != nil {
					_ = c.WriteClose(http.StatusInternalServerError)
				}
				return
			}
			handler := func(_ interface{}, stream grpc.ServerStream) error {
				return srv.Stream(&myServiceStreamServer{stream})
			}
			info := &grpc.StreamServerInfo{
				FullMethod:     "/example.MyService/Stream",
				IsClientStream: true,
				IsServerStream: true,
			}
			if err = streamInterceptor(srv, stream, info, handler); err != nil {
				_ = c.WriteClose(http.StatusInternalServerError)
			}
		}
		websocket.Handler(fn).ServeHTTP(w, r)
	})

	return nil
}

var (
	ws_pattern_MyService_Stream_0 = runtime.MustPattern(runtime.NewPattern(1, []int{2, 0, 2, 1, 2, 2}, []string{"my-service", "v1", "streaming"}, ""))
)
